# 网络相关

## 网络协议

各层的协议：![network-agreement](../images/network-agreement.png)

Mac地址局域网寻址，IP地址网络寻址

## 传输层UDP与TCP：

**TCP是一个面向连接的、可靠的、基于字节流的传输层协议。**而**UDP是一个面向无连接的传输层协议。**区别：

|              | UDP                                    | TCP                              |
| :----------- | -------------------------------------- | -------------------------------- |
| 是否连接     | 无连接                                 | 面向连接                         |
| 是否可靠     | 不可靠传输，不能使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 一对一、一对多、多对一和多对多         | 一对一通信                       |
| 传输方式     | 面向报文                               | 面向字节流                       |
| 首部开销     | 8字节                                  | 最小20字节，最大60字节           |
| 适用场景     | 实时应用                               | 可靠传输应用，如文件传输         |

具体来分析，和 `UDP` 相比，`TCP` 有三大核心特性:

1. **面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. **可靠性**。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。相应的，UDP 就是`无状态`, `不可控`的。
3. **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

TCP通过以下方式提供可靠性：

1. 用数据被分割成 TCP 认为最合适发送的数据块，即进行TCP 分段。这点与 UDP 完全不同，应用程序产生的UDP 数据报长度将保持不变，在 IP 层将 UDP 数据报加上IP 首部后，必要时对其进行 IP 分片。
2. 当 TCP 发出一个报文段后，它会启动一个定时器，等待目的端确认收到这个报文段，如果没能及时收到该确认信息，则将重发这个报文段。即超时重传。
3. 当 TCP 接收端收到连接另一端的 TCP 报文段时，它将发送一个确认，这个确认不是立即发送的，通常会推迟几分之一秒。即确认应答（ACK）。
4. TCP 将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检查数据在传输过程中的任何变化。如果收到的报文段的校验和有差错，TCP 将丢弃该报文段，同时不发送确认收到的消息，从而使发送端超时重发。
5. 由于 TCP 报文段作为 IP 数据报来传输，IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能失序，如果必要，TCP 将对收到的数据进行重排序，将收到的数据以正确的顺序交给应用层。 
6. 由于 IP 数据报有可能发生重复，TCP 的接收端必须丢弃重复的数据。
7. TCP 能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接受端只允许另一端发送接收端缓冲区所能接纳的数据，这将防止较快主机致使较慢主机的缓冲区溢出。即流量控制。

### TCP端口状态



## 七层协议

## ![tcp-seven-level](../images/tcp-seven-level.gif)

与四层协议之间的对应![network-level](../images/network-level.png)

发送与接收![network-transport](../images/network-transport.jpeg)

## TCP拥塞控制算法

1. Reno算法，适用于低延时、低带宽的网络，将拥塞控制的过程分为四个阶段：慢启动、拥塞避免、快重传和快恢复。对应状态如下图：![tcp-reno](../images/tcp-reno.jpeg)
   - 慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；
   - 当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认；
   - 快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程
2. BBR算法，经典的拥塞控制算法比如reno/newReno/Cubic无一例外都是将丢包作为拥塞的信号，然后降低发送速率。而在该算法中，不考虑丢包，而是基于这样一个定义：当网络上的包数大于BDP(带宽时延乘积)时，就认为出现了拥塞。 TCP BBR致力于解决两个问题：
   - 在有一定丢包率的网络链路上充分利用带宽
   - 降低网络链路上的buffer占用率，从而降低延迟。

## 三次握手、四次挥手

### TCP三次握手

三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了**确认双方的接收能力和发送能力是否正常**、指定自己的初始化序列号和为后面的可靠性传输做准备。   实质就是连接服务器指定端口，建立TCP连接。刚开始客户端处于Closed的状态，服务端处于Listen状态，进行三次握手：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_REVD` 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

发送第一个SYN的一端将执行主动打开，接收这个SYN并返回下一个SYN的另一端执行被动打开。Socket编程中，客户端执行connect()时，也会触发三次握手。如图：

![tcp-threehand](../images/tcp-threehand.png)

#### 为什么不是2次呢？

根本原因: 无法确认客户端的接收能力。分析如下:

如果是两次，你现在发了 SYN 报文想握手，但是这个包**滞留**在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。看似没有问题，但是连接关闭后，如果这个**滞留**在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了，这就带来了连接资源的浪费。

#### 为什么不是四次？

三次握手的目的是确认双方`发送`和`接收`的能力，那四次握手可以嘛？当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

#### 三次握手过程中可以携带数据么？

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

#### 同时打开会怎样？

如果双方同时发 `SYN`报文，状态变化会是怎样的呢？这是一个可能会发生的情况。状态变迁如下:

![httpsametime](../images/httpsametime)

在发送方给接收方发`SYN`报文的同时，接收方也给发送方发`SYN`报文，两个人刚上了!发完`SYN`，两者的状态都变为`SYN-SENT`。在各自收到对方的`SYN`后，两者状态都变为`SYN-REVD`。接着会回复对应的`ACK + SYN`，这个报文在对方接收之后，两者状态一起变为`ESTABLISHED`。这就是同时打开情况下的状态变迁。

### TCP四次挥手

过程如下：

![tcp4close](../images/tcp4close.png)



[三次握手详解](https://juejin.im/post/5d9c284b518825095879e7a5)



### Https详解

Https与Http的区别![httpandhttps](../images/httpandhttps.png)HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：

- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
- 对网站服务器进行真实身份认证

Https工作原理![https](../images/https.png)

CA相关流程 (CertificateAuthority)![httpsca](../images/httpsca.png)

