## 链表相关

1、单链表反转

2、两个有序链表合并

3、两个链表返回第一个公共节点

1）暴力匹配

2）哈希

3）找到长度差，然后挨个匹配

4）两个链表一起遍历，短链表遍历完之后指向长链表，长链表遍历完指向短链表，然后就会相交了。

4、如何判断一个链表中是否存在环（若有环，求环的长度和入口点）

5、接取出单链表中的后K个节点（k>0)

6、去除有序链表中的重复元素（一个有序链表，删除所有重复的元素，保证每个元素在链表中只出现一次）

7、求链表的中间节点，给定一个带有头节点的非空单链表，返回链表的中间节点，如果有两个，返回第二个。

输入：[1,2,3,4,5]，输出：此列表中的结点 3 ，返回的节点值为3。

8、删除链表中的节点 (leetcode 237)，请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。也就是你仅知道要求被删除的节点。输入: head = [4,5,1,9], node = 5 输出: [4,1,9]

9、删除链表的倒数第N个节点(leetcode 19)，给定一个链表: 1->2->3->4->5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1->2->3->5.

## TopK问题解法

**怎么在无序数组中找到第几（K）大元素？**

算法A 将数组中元素升序排列，找到数组下标k-1的元素即可。这是最容易想到的方法，如果使用简单的排序算法，时间复杂度为O(n^2)。

算法B  初始化长度为K的数组，读入元素，然后对K个元素降序排序，这时第K大元素就在最后一个；读入下一个元素与第K大元素比较，如果大于，删掉第K个元素，将读入的元素插入正确的位置。时间复杂度分析：第一步采用普通排序算法时间复杂度是O(k^2)；第二步：(N-k)*(k-1) = Nk-k^2+k。所以算法B的**时间复杂度为O(NK)**。**当k=N/2（向下取整）时，时间复杂度还是O(n^2)。**其实求第K大问题，也可以求反，即求第N-k+1小问题。这是等价的。**所以当K=N/2时**，是最难的地方，但也很有趣，这时候的**K对应的值就是中位数。**

算法C	将数据读入一个数组，对数组进行buildHeap(我们这里构建大顶堆)，之后对堆进行K次deleteMax操作，第K次的结果就是我们需要的值。

算法D	我们采用算法B的思想，只是我们这里构建一个节点数为K的小顶堆，只要下一个数比根节点大，就删除根节点，并将这个数进行下滤操作。所以算法最终的第K大数就是根节点的数。**时间复杂度：**对K个数进行buildHeap是O(k)，最坏情况下假设剩下的N-k个数都要进入堆中进行下滤操作，**总的需要O(k+(N-k)logk)。如果K为N/2，则需要O(NlogN)。**

算法E	快速选择  如果S中元素个数是1，那么k=1并将S中的元素返回。如果正在使用小数组的截止方法且|S|<=CUTOFF，则将S排序并返回第K个最大元素

选取一个S中的元素v，称之为枢纽元（pivot）；将S-{v}（S中除了枢纽元中的其余元素）划分为两个不相交的集合S1和S2，S1集合中的所有元素小于等于枢纽元v，S2中的所有元素大于等于枢纽元；如果k<=|S1|，那么第k个最大元必然在S1中。这时，我们返回quickSelect(S1，k)。如果k=1+|S1|，那么枢纽元就是第k个最大元，我们直接返回枢纽元。否则，这第k个最大元一定在S2中，它就是S2中的第（k-|S1|-1）个最大元。我们进行一次递归调用并返回quickSelect(S2，k-|S1|-1)。


