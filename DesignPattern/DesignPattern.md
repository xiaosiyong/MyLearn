### SOLID 设计模式
1、简单工厂模式：例子，加减乘除。定义运算类，通过工厂来调用具体的实体类。

2、策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响使用算法的客户。

**OO的五大原则：**
SOLID
1. S：Single Responsibility Principle（SRP） 单一职责原则，即表示：类的职责要单一，不要多管闲事也不要丢三落四。
2. O：Open & Close Principle（OCP） 开闭原则，即表示：在设计一个系统时，你是否把类设计得十分合理。而检测的标准就是，当有新的需求增加或变化时，你是否是编写新代码来满足而不是改动原有代码。当然事情可能没有那么绝对，但至少是要向着这个方向努力：对修改关闭（尽量不要让变化影响到已经设计好的类），对扩展开放（新的逻辑采用添加新代码即可实现）。
3. L：Liskov Substitution Principle（LSP） 里氏替换原则，即表示：在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用，如：
1 class ParentClass{}
2 class SubClass : ParentClass{}
3 ParentClass pc = new SubClass();
这样来理解有些片面，但实际编程过程中基本上是这样来处理代码；其实也体现了一个原则：采用抽象来封装变化，在这里ParentClass就可以理解为“抽象”（abstract class ParentClass）来封装子类的变化，不依赖于子类的具体实现，也不需要关系到底有多少个子类。
4. I：Interface Segregation Principle（ISP） 接口分隔原则，即表示：采用多个与特定逻辑有关的接口总是比采用一个涵盖所有业务方法的接口要好。这也可以从职责单一这个角度去理解，当业务的组合关系比较复杂多变的时候，通过多个单一职责的接口的组合来实现往往会让代码结构更加清晰易于维护和扩展。
5. D：Dependence Inversion Principle（DIP） 依赖倒置原则，即表示：依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化。
